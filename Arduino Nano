/**
 * ==========================================================
 * SWERVE-PRINT PRO : SLAVE FIRMWARE (ARDUINO NANO)
 * ==========================================================
 * GESTION : CINÉMATIQUE XY + MODE TÉLÉCOMMANDE (REMOTE)
 */

#include <AccelStepper.h>
#include <VirtualWire.h>

// --- PARAMÈTRES MÉCANIQUES CONFIGURABLES ---
#define STEPS_PER_DEG 8.88    // 3200 steps pour 360° (Microstepping 1/16)
#define STEPS_PER_MM  80.0    // Exemple : Poulie GT2 20 dents
#define AUTO_REMOTE_TIME 7200000 // 2 heures en millisecondes

// --- PINS TÉLÉCOMMANDE (RECEIVER) ---
const int PIN_BTN_MODE = 4;   // Bouton pour forcer le mode manuel
const int RF_RX_PIN = 11;     // Pin de données du récepteur RF

// --- PINS MOTEURS (Exemple pour 1 module, répéter pour 4) ---
AccelStepper pivot(1, 5, 6);   // Step, Dir
AccelStepper traction(1, 7, 8);

bool isRemoteMode = false;
unsigned long startTime;

void setup() {
  Serial.begin(115200); // Communication avec Mega
  pinMode(PIN_BTN_MODE, INPUT_PULLUP);

  // --- Initialisation du récepteur RF ---
  vw_set_rx_pin(RF_RX_PIN);
  vw_setup(2000); // bps (Bits Per Second)
  vw_rx_start();   // Démarrer la réception

  pivot.setMaxSpeed(2000);
  traction.setMaxSpeed(3000);
  
  startTime = millis();
}

void loop() {
  // --- LOGIQUE DE CHANGEMENT DE MODE ---
  if (digitalRead(PIN_BTN_MODE) == LOW || (millis() - startTime > AUTO_REMOTE_TIME)) {
    if (!isRemoteMode) {
      isRemoteMode = true;
      Serial.println("MODE: REMOTE_ACTIVE");
    }
  }

  if (isRemoteMode) {
    handleRemoteControl();
  } else {
    handleMasterGCode();
  }
}

void handleMasterGCode() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('
');
    if (cmd.startsWith("MOVE")) {
      // --- EXTRACTION DES VALEURS ---
      int indexA = cmd.indexOf('A');
      int indexD = cmd.indexOf('D');

      // Commande mal formée ou paramètres dans le mauvais ordre
      if (indexA == -1 || indexD == -1 || indexA > indexD) return;

      float angle = cmd.substring(indexA + 1, indexD).toFloat();
      float dist = cmd.substring(indexD + 1).toFloat();

      // --- CINÉMATIQUE SWERVE ---
      // 1. Orienter les roues
      pivot.moveTo(angle * STEPS_PER_DEG);

      // 2. Préparer le mouvement de traction
      // Note: AccelStepper.move() est un mouvement relatif
      traction.move(dist * STEPS_PER_MM);

      // 3. Exécuter les deux mouvements jusqu'à la fin
      // La librairie gère l'accélération et la vitesse pour nous.
      while(pivot.distanceToGo() != 0 || traction.distanceToGo() != 0) {
        pivot.run();
        traction.run();
      }
      // --- HANDSHAKE ---
      // Confirmer au Mega que le mouvement est terminé et qu'on est prêt.
      Serial.println("OK");
    }
  }
}

/**
 * LOGIQUE TÉLÉCOMMANDE (Pilotage par RF)
 */
void handleRemoteControl() {
  uint8_t buf[VW_MAX_MESSAGE_LEN];
  uint8_t buflen = VW_MAX_MESSAGE_LEN;

  // Si on reçoit un message RF...
  if (vw_get_message(buf, &buflen)) {
    char command[buflen];
    for(int i=0; i<buflen; i++) command[i] = (char)buf[i];
    command[buflen] = '\0'; // Terminer la chaîne de caractères
    
    float targetAngle = -1; // -1 = Pas de mouvement de pivot

    // --- INTERPRÉTATION DES COMMANDES REÇUES ---
    if (strcmp(command, "FWD") == 0)      targetAngle = 0;
    else if (strcmp(command, "BWD") == 0) targetAngle = 180;
    else if (strcmp(command, "RGT") == 0) targetAngle = 90;
    else if (strcmp(command, "LFT") == 0) targetAngle = 270;
    else if (strcmp(command, "FR") == 0)  targetAngle = 45;
    else if (strcmp(command, "FL") == 0)  targetAngle = 315;
    else if (strcmp(command, "BR") == 0)  targetAngle = 135;
    else if (strcmp(command, "BL") == 0)  targetAngle = 225;

    if (targetAngle != -1) {
      // 1. Orienter les roues
      pivot.moveTo(targetAngle * STEPS_PER_DEG);

      // 2. Préparer le mouvement de traction
      traction.move(100 * STEPS_PER_MM); // Avancer de 10cm par commande

      // 3. Exécuter les deux en parallèle
      while(pivot.distanceToGo() != 0 || traction.distanceToGo() != 0) {
        pivot.run();
        traction.run();
      }
    }
    // Si la commande est "STOP", on arrête la traction.
    else if (strcmp(command, "STOP") == 0) {
      traction.stop(); // Arrêt progressif
    }
  }
}
